# Copyright 2025 Xiaojuan Cheng
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.






import math
import time
import numpy as np
import pandas as pd
import networkx as nx
from network import create_multiplex_network_with_connected_nodes_edges, normalized_matrix

paraA = 1
if paraA == 1:
    def sigma(x):
        return 0.1 * np.tanh(x)
    def sigma_derivative(x):
        return 1 - np.tanh(x)**2

if paraA == 2:
    def sigma(x):
        return 1 / (1.1 + np.exp(7 * x - 2))
    def sigma_derivative(x):
        exp_term = np.exp(7 * x - 2)
        return -7 * exp_term / ((1.1 + exp_term) ** 2)

if paraA == 3:
    def sigma(x):
        return -0.5 * (x ** 2) + 1
    def sigma_derivative(x):
        return -1 * x

if paraA == 4:
    def sigma(x):
        return -0.7 * x + 0.5
    def sigma_derivative(x):
        return -0.7


def f(x):
    return 0.2 * x/(x+1)

def g(x):
    return 0.2 * math.log(x+1)


def forward_C(pulse_interval_A):
    for t in range(t_scale - 1):
        if t in pulse_interval_A:
            c[t] = c[t] - f(u1[t]) * c[t]
            dc = sigma(o[t]) * ((A @ c[t]).A1) * (1 - c[t]) - zeta * c[t]
            c[t + 1] = c[t] + h * dc
        else:
            dc = sigma(o[t]) * ((A @ c[t]).A1) * (1 - c[t]) - zeta * c[t]
            c[t + 1] = c[t] + h * dc
    return c


def forward_O(pulse_interval_B):
    for t in range(t_scale - 1):
        if t in pulse_interval_B:
            o[t] = o[t] + g(u2[t]) * o[t]
            do = rho * (c[t] - o[t]) + (1 - rho) * (1 - o[t]) * ((W - D) @ o[t]).A1
            o[t + 1] = o[t] + h * do
        else:
            do = rho * (c[t] - o[t]) + (1 - rho) * (1 - o[t]) * ((W - D) @ o[t]).A1
            o[t + 1] = o[t] + h * do
    return o


def backward_dlamb(pulse_interval_A):
    for t in range(t_scale - 1, 0, -1):
        mat_lamb1 = A @ c[t]
        mat_lamb2 = A @ ((1 - c[t]) * lamb[t] * sigma(o[t]))
        if t in pulse_interval_A:
            lamb[t] = lamb[t] - lamb[t] * f(u1[t])
            dlamb = -omega + lamb[t] * (sigma(o[t]) * mat_lamb1.A1 + zeta) - mat_lamb2.A1 - mu[t] * rho
            lamb[t - 1] = lamb[t] - h * dlamb
        else:
            dlamb = -omega + lamb[t] * (sigma(o[t]) * mat_lamb1.A1 + zeta) - mat_lamb2.A1 - mu[t] * rho
            lamb[t - 1] = lamb[t] - h * dlamb
    return dlamb


def backward_dmu(pulse_interval_B):
    for t in range(t_scale - 1, 0, -1):
        mat_mu3 = A @ c[t]
        mat_mu4 = ((W - D) @ o[t]).A1
        mat_mu5 = ((1 - o[t]) @ W).A1
        mat_mu6 = (W @ (1 - rho)).A1
        if t in pulse_interval_B:
            mu[t] = mu[t] + mu[t] * g(u2[t])
            dmu = - lamb[t] * (1 - c[t]) * mat_mu3.A1 * sigma_derivative(o[t]) + mu[t] * rho + mu[t] * (1 - rho) * (mat_mu4 + mat_mu5) -  mu[t] * mat_mu6 * (1 - o[t])
            mu[t - 1] = mu[t] - h * dmu
        else:
            dmu = - lamb[t] * (1 - c[t]) * mat_mu3.A1 * sigma_derivative(o[t]) + mu[t] * rho + mu[t] * (1 - rho) * (mat_mu4 + mat_mu5) - mu[t] * mat_mu6 * (1 - o[t])
            mu[t - 1] = mu[t] - h * dmu
    return dmu


def payoff():
    sum_c = sum(c[t].sum(axis=0) for t in range(t_scale))
    sum_u1 = sum(u1[t] for t in range(t_scale))
    sum_u2 = sum(u2[t] for t in range(t_scale))
    ob_j = omega * sum_c * h + sum_u1 + sum_u2
    return ob_j


def optimalStrategy(pulse_interval_A, pulse_interval_B):
    aa = np.arange(u1_low, u1_upp + step_u, step_u)
    bb = np.arange(u2_low, u2_upp + step_u, step_u)
    for t in range(t_scale):
        if t in pulse_interval_A:
            s=[]
            for temp in aa:
                H21 = temp - np.sum(lamb[t] * f(temp) * c[t])
                s.append(H21)
            H21_index = np.argmin(s)
            optimal_u1[t] = aa[H21_index]

        if t in pulse_interval_B:
            s = []
            for temp in bb:
                # H22 = temp - np.sum(mu[t] * g(temp) * o[t])
                H22 = temp + np.sum(mu[t] * g(temp) * o[t])
                s.append(H22)
            H22_index = np.argmin(s)
            optimal_u2[t] = bb[H22_index]

    return optimal_u1, optimal_u2


def impsequence(start, interval, tscale, max_count, mode):
    """
    Args:
        start (int): 1，2，3...
        interval (int): 1，2，3...
        tscale (int): t_scale = int(T / h)
        max_count (int): 1, 2, 3, 4
    """
    end = tscale - 1
    numbers = list(range(start, end, interval))
    if mode == 1:
        if max_count <= len(numbers):
            implist = numbers[:max_count]
        else:
            print("max_count less than the default value")
            implist = numbers[:max_count]
            print("max_count = {}".format(len(numbers)))
    elif mode == 2:
        if max_count <= len(numbers):
            implist = numbers[:max_count]
        else:
            print("max_count less than the default value")
            implist = numbers[:max_count]
            print("max_count = {}".format(len(numbers)))

    return implist


if __name__ == '__main__':
    file_path = './data/email-univ/email-univ.edges'
    original_social_network, social_network, scale_free_network = create_multiplex_network_with_connected_nodes_edges(
        file_path, max_nodes=1000, seed=3, map=True, visualize=False)

    tem1 = nx.adjacency_matrix(scale_free_network)
    tem2 = nx.adjacency_matrix(social_network)
    A = tem1.todense()
    W = normalized_matrix(tem2)
    D = np.sum(W, axis=1)
    D = np.diag(D.A1)

    nodes = social_network.nodes

    T = 5
    h = 0.001
    t_scale = int(T / h) + 1

    c = np.full((t_scale, len(nodes)), 0.5)
    o = np.full((t_scale, len(nodes)), 0.3)

    lamb = np.zeros((t_scale, len(nodes)))
    mu = np.zeros((t_scale, len(nodes)))

    omega = 0.2
    zeta = 0.2
    rho = np.full(len(nodes), 0.7)
    u1 = np.zeros(t_scale)
    u2 = np.zeros(t_scale)

    optimal_u1 = np.zeros(t_scale)
    optimal_u2 = np.zeros(t_scale)
    maxiter = 10
    j = np.zeros(maxiter + 1)

    up = 5
    low = 0.1
    step = 0.1
    u1_low = low + 0.4
    u1_upp = up
    u2_low = low + 0.2
    u2_upp = (up - 2)
    step_u = step

    start1 = 105
    interval1 = 540
    start2 = 105
    interval2 = 530

    mode = 2
    max_count = 10
    imp_list_A = impsequence(start1, interval1, t_scale, max_count, mode)
    imp_list_B = impsequence(start2, interval2, t_scale, max_count, mode)

    t1 = time.time()
    c = forward_C(imp_list_A)
    o = forward_O(imp_list_B)
    j[0] = payoff()

    for iter in range(0, maxiter):
        t3 = time.time()
        dlamb = backward_dlamb(imp_list_A)
        dmu = backward_dmu(imp_list_B)
        u1, u2 = optimalStrategy(imp_list_A, imp_list_B)
        c = forward_C(imp_list_A)
        o = forward_O(imp_list_B)
        j[iter+1] = payoff()
        t4 = time.time()
        print("Iter Time Consumption:", t4 - t3)

    t2 = time.time()
    print("Time Consumption:", t2-t1)

    x = np.arange(maxiter + 1)
    y = j

    a = 'experiment_1'
    data1 = {"maxiter": x, "J": y}
    df1 = pd.DataFrame(data1)
    df1.to_csv('./result_data/' + a + '/J.csv', index=False)
    data2 = {"imp_list_A": imp_list_A, "imp_list_B": imp_list_B}
    df2 = pd.DataFrame(data2)
    df2.to_csv('./result_data/' + a + '/imp.csv', index=False)
    df3 = pd.DataFrame(o)
    df3.to_csv('./result_data/' + a + '/o.csv', index=False)
    df4 = pd.DataFrame(c)
    df4.to_csv('./result_data/' + a + '/c.csv', index=False)
    data5 = {"value_A": u1, "value_B": u2}
    df5 = pd.DataFrame(data5)
    df5.to_csv('./result_data/' + a + '/u1u2.csv', index=False)


